<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FUMO | ZEN PROTOCOL</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@500;800&family=JetBrains+Mono:wght@300;400&family=Inter:wght@700;900&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        mincho: ['Shippori Mincho', 'serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'chart-green': '#22c55e',
                    }
                }
            }
        }
    </script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <style>
        /* 100dvh ensures full height on mobile browsers */
        body, html {
            background-color: #FAFAFA;
            color: #111;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh; 
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        /* Loading Screen */
        #static-loader {
            position: fixed; inset: 0; background: #FAFAFA; z-index: 9999;
            display: flex; justify-content: center; align-items: center;
            font-family: monospace; font-size: 10px; letter-spacing: 0.2em; color: #999;
            transition: opacity 0.5s ease-out;
            pointer-events: none;
        }
        .loaded #static-loader { opacity: 0; }

        /* Glitch */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .glitch-active {
            animation: shake 0.15s cubic-bezier(.36,.07,.19,.97) both;
            text-shadow: 3px 0 #ff0000, -3px 0 #22c55e;
        }
        .invert-mode {
            filter: invert(100%);
            background: #000;
        }
    </style>
</head>
<body>
    <div id="static-loader">SYSTEM INITIALIZING...</div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        const { motion, AnimatePresence } = window.Motion;

        // --- üõ°Ô∏è ROBUST AUDIO ENGINE ---
        let audioCtx = null;
        let lastSoundTime = 0;
        const playSound = (type) => {
            const now = Date.now();
            if (now - lastSoundTime < 50) return;
            lastSoundTime = now;
            try {
                if (!audioCtx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioCtx = new AudioContext();
                }
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const t = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                if (type === 'tick') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(1200 + Math.random() * 600, t);
                    gain.gain.setValueAtTime(0.005, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                    osc.start(t);
                    osc.stop(t + 0.05);
                } else if (type === 'switch') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, t);
                    gain.gain.setValueAtTime(0.05, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
                    osc.start(t);
                    osc.stop(t + 0.3);
                } else if (type === 'glitch') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(60, t);
                    gain.gain.setValueAtTime(0.05, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    osc.start(t);
                    osc.stop(t + 0.1);
                } else if (type === 'complete') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, t);
                    osc.frequency.exponentialRampToValueAtTime(880, t + 1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 3);
                    osc.start(t);
                    osc.stop(t + 3);
                }
            } catch(e) {}
        };

        // --- üìä DATA ---
        const MODES = {
            LEGENDS: { id: 'LEGENDS', label: 'LEGENDS / ÊäïË≥á„ÅÆÁ•ûÈ´Ñ', timerLabel: { jp: 'Áü•ÊÅµ„ÇíÂæó„Çã„Åæ„Åß', en: 'UNTIL WISDOM' }, words: [
                { jp: "„É´„Éº„É´1ÔºöÊêç„Çí„Åô„Çã„Å™„ÄÇ", en: "RULE 1: NEVER LOSE" }, { jp: "ÊÇ≤Ë¶≥„ÅÆ‰∏≠„ÅßË≤∑„ÅÑ„ÄÅÊ•ΩË¶≥„ÅßÂ£≤„Çå„ÄÇ", en: "BUY THE BLOOD" },
                { jp: "‰ºë„ÇÄ„Åì„Å®„ÇÇÁõ∏Â†¥„Å†„ÄÇ", en: "SITTING IS MONEY" }, { jp: "Áõ∏Â†¥„ÅØÂ∏∏„Å´Ê≠£„Åó„ÅÑ„ÄÇ", en: "MARKET IS NEVER WRONG" },
                { jp: "Âçµ„Çí‰∏Ä„Å§„ÅÆ„Ç´„Ç¥„Å´Áõõ„Çã„Å™„ÄÇ", en: "DIVERSIFY" }, { jp: "ÂôÇ„ÅßË≤∑„Å£„Å¶„ÄÅ‰∫ãÂÆü„ÅßÂ£≤„Çå„ÄÇ", en: "BUY RUMOR, SELL FACT" },
                { jp: "Âº∑Ê∞óÁõ∏Â†¥„ÅØÊÇ≤Ë¶≥„ÅÆ‰∏≠„ÅßÁîü„Åæ„Çå„Çã„ÄÇ", en: "BULLS BORN IN GLOOM" }, { jp: "ËêΩ„Å°„Çã„Éä„Ç§„Éï„ÇíÊé¥„ÇÄ„Å™„ÄÇ", en: "DONT CATCH KNIVES" },
                { jp: "Âà©È£ü„ÅÑÂçÉ‰∫∫Âäõ„ÄÇ", en: "PROFIT IS PROFIT" }, { jp: "Êú®„ÇíË¶ã„Å¶Ê£Æ„ÇíË¶ã„Åö„ÄÇ", en: "SEE THE FOREST" },
                { jp: "‰∫∫„ÅÆË°å„ÅèË£è„Å´ÈÅì„ÅÇ„Çä„ÄÇ", en: "BE CONTRARIAN" }, { jp: "È†≠„Å®Â∞ªÂ∞æ„ÅØ„Åè„Çå„Å¶„ÇÑ„Çå„ÄÇ", en: "NO GREED" },
                { jp: "‰æ°Ê†º„ÅØÊîØÊâï„ÅÜ„ÇÇ„ÅÆ„ÄÅ‰æ°ÂÄ§„ÅØÂæó„Çã„ÇÇ„ÅÆ„ÄÇ", en: "PRICE IS WHAT YOU PAY" }, { jp: "Á®≤Â¶ª„ÅåËºù„ÅèÁû¨Èñì„Å´Â∏ÇÂ†¥„Å´„ÅÑ„Çç„ÄÇ", en: "TIME IN THE MARKET" },
                { jp: "ÁêÜËß£„Åß„Åç„Å™„ÅÑ„ÇÇ„ÅÆ„Å´ÊäïË≥á„Åô„Çã„Å™„ÄÇ", en: "KNOW WHAT YOU OWN" }, { jp: "‰ªñ‰∫∫„ÅåÂº∑Ê¨≤„Å™ÊôÇ„Å´ÊÅê„Çå„Çà„ÄÇ", en: "FEAR WHEN OTHERS GREEDY" },
                { jp: "‰∫àÊ∏¨„Åô„Çã„Å™„ÄÅÊ∫ñÂÇô„Åõ„Çà„ÄÇ", en: "DONT PREDICT, PREPARE" }, { jp: "Â∏ÇÂ†¥„ÅØÁü≠ÊúüÁöÑ„Å´„ÅØÊäïÁ•®Ê©ü„Å†„ÄÇ", en: "MARKET IS VOTING MACHINE" },
                { jp: "Èï∑ÊúüÁöÑ„Å´„ÅØË®àÈáèÂô®„Åß„ÅÇ„Çã„ÄÇ", en: "LONG TERM IS WEIGHING" }, { jp: "ÊêçÂàá„Çä„ÅØÁ¥†Êó©„Åè„ÄÇ", en: "CUT LOSSES FAST" },
                { jp: "Âà©Áõä„ÅØ‰º∏„Å∞„Åõ„ÄÇ", en: "LET PROFITS RUN" }
            ]},
            FOMO: { id: 'FOMO', label: 'ANTI-FOMO / È´òÂÄ§Êé¥„ÅøÈò≤Ê≠¢', timerLabel: { jp: 'Ê≠£Ê∞ó„Å´Êàª„Çã„Åæ„Åß', en: 'UNTIL SANITY' }, words: [
                { jp: "È´òÂÄ§Êé¥„Åø„ÅØÊâçËÉΩ„ÄÇ", en: "TOP BUYER TALENT" }, { jp: "„Åæ„ÅüÈ§äÂàÜ„Å´„Å™„ÇãÊ∞ó„ÅãÔºü", en: "EXIT LIQUIDITY?" },
                { jp: "Èù¥Á£®„Åç„ÅÆÂ∞ëÂπ¥„ÇíË¶ã„Çç„ÄÇ", en: "SIGNAL IS OUT" }, { jp: "JOMO„ÇíÁü•„Çå„ÄÇ", en: "JOY OF MISSING OUT" },
                { jp: "Èö£„ÅÆËäù„ÅØ„ÄÅÈõªÂ≠ê„Ç¥„Éü„ÄÇ", en: "OTHER BAGS ARE DUST" }, { jp: "„Ç§„É≥„Éï„É´„Ç®„É≥„Çµ„Éº„ÅØÂòò„Å§„Åç„ÄÇ", en: "GURUS LIE" },
                { jp: "„Ç§„Éä„Ç¥„Çø„ÉØ„ÉºÂª∫Ë®≠‰∏≠„ÄÇ", en: "PONZI TOWER" }, { jp: "„Åù„ÅÆÈôΩÁ∑ö„ÅØÁΩ†„Å†„ÄÇ", en: "GREEN TRAP" },
                { jp: "„Å©„ÅÜ„ÅõÂ£≤„Çâ„Å™„ÅÑ„Å†„Çç„ÄÇ", en: "YOU HODL ANYWAY" }, { jp: "Êúà„Å´„ÅØÈÖ∏Á¥†„Åå„Å™„ÅÑ„ÄÇ", en: "MOON HAS NO AIR" },
                { jp: "„Åù„ÅÆÈáë„ÄÅÁÑ°„Åã„Å£„Åü„ÇÇ„ÅÆ„ÄÇ", en: "MONEY WAS ILLUSION" }, { jp: "‰πó„ÇäÈÅÖ„Çå„Åü„Éê„Çπ„ÇíËøΩ„ÅÜ„Å™„ÄÇ", en: "DONT CHASE THE BUS" },
                { jp: "Ê¨°„ÅØÂøÖ„ÅöÊù•„Çã„ÄÇ", en: "NEXT TRAIN COMING" }, { jp: "„ÉÅ„É£„Éº„Éà„ÇíÈñâ„Åò„Çç„ÄÅÊ≠ª„Å¨„Åû„ÄÇ", en: "CLOSE CHART OR DIE" },
                { jp: "ÊÄùËÄÉÂÅúÊ≠¢„Åô„Çã„Å™„ÄÇ", en: "DONT STOP THINKING" }, { jp: "„ÅäÂâç„ÅØ„Ç´„É¢„Å†„ÄÇ", en: "YOU ARE THE SUCKER" },
                { jp: "ÁÑº„Åã„Çå„Çã„ÅÆ„ÅØÂ∏∏„Å´ÂæåÁô∫ÁµÑ„ÄÇ", en: "LATECOMERS GET BURNED" }, { jp: "Êú¨ÂΩì„Å´„Åù„ÅÆ‰æ°ÂÄ§„ÅØ„ÅÇ„Çã„ÅãÔºü", en: "IS IT WORTH IT?" },
                { jp: "Ê∑±ÂëºÂê∏„Åó„Çç„ÄÇ", en: "TAKE A BREATH" }, { jp: "È£õ„Å≥‰πó„ÇäÁ¶ÅÊ≠¢„ÄÇ", en: "NO JUMPING IN" }
            ]},
            PANIC: { id: 'PANIC', label: 'ANTI-PANIC / ÁãºÁãΩÂ£≤„ÇäÈò≤Ê≠¢', timerLabel: { jp: 'Âµê„ÅåÈÅé„Åé„Çã„Åæ„Åß', en: 'UNTIL CALM' }, words: [
                { jp: "Â£≤„Çâ„Å™„Åç„ÇÉÊêç„Åò„ÇÉ„Å™„ÅÑ„ÄÇ", en: "1 BTC = 1 BTC" }, { jp: "„Éê„Éº„Ç≤„É≥„Çª„Éº„É´ÈñãÂÇ¨‰∏≠„ÄÇ", en: "BUY THE DIP" },
                { jp: "Êè°Âäõ„ÇíË©¶„Åï„Çå„Å¶„ÅÑ„Çã„ÄÇ", en: "DIAMOND HANDS" }, { jp: "ÊÅêÊÄñ„ÅßË≤∑„Åà„ÄÇ", en: "BUY THE FEAR" },
                { jp: "ÈÄÄÂ†¥„Åó„Å™„Åë„Çå„Å∞Âãù„Å°„ÄÇ", en: "SURVIVAL IS WIN" }, { jp: "ÁèæÁâ©„ÅØË£èÂàá„Çâ„Å™„ÅÑ„ÄÇ", en: "SPOT IS SAFE" },
                { jp: "Ê≠¥Âè≤„ÅØÁπ∞„ÇäËøî„Åô„ÄÇ", en: "ZOOM OUT" }, { jp: "PC„ÇíÈñâ„Åò„Çç„ÄÇ", en: "CLOSE TERMINAL" },
                { jp: "„ÅäÂâç„ÅØ„ÇØ„Ç∏„É©„Åò„ÇÉ„Å™„ÅÑ„ÄÇ", en: "YOU ARE PLANKTON" }, { jp: "Âµê„ÅØÈÅé„ÅéÂéª„Çã„ÄÇ", en: "STORM WILL PASS" },
                { jp: "ÁãºÁãΩÂ£≤„Çä„ÅØÈ§äÂàÜ„ÅÆË®º„ÄÇ", en: "PANIC SELLING IS WEAK" }, { jp: "Â∫ï„ÅØË™∞„Å´„ÇÇÂàÜ„Åã„Çâ„Å™„ÅÑ„ÄÇ", en: "NO ONE KNOWS BOTTOM" },
                { jp: "‰ø°Âøµ„ÇíÊåÅ„Å¶„ÄÇ", en: "HAVE CONVICTION" }, { jp: "ÊÅêÊÄñ„ÅØ„ÉÅ„É£„É≥„Çπ„Å†„ÄÇ", en: "FEAR IS OPPORTUNITY" },
                { jp: "„Åæ„Å†ÁµÇ„Çè„Å£„Å¶„ÅÑ„Å™„ÅÑ„ÄÇ", en: "NOT OVER YET" }, { jp: "Â§úÊòé„ÅëÂâç„Åå‰∏ÄÁï™Êöó„ÅÑ„ÄÇ", en: "DARKEST BEFORE DAWN" },
                { jp: "ÊÑüÊÉÖ„ÇíÊÆ∫„Åõ„ÄÇ", en: "KILL EMOTION" }, { jp: "Ë®àÁîª„ÇíÊÄù„ÅÑÂá∫„Åõ„ÄÇ", en: "REMEMBER THE PLAN" },
                { jp: "„Éé„Ç§„Ç∫„ÇíÈÅÆÊñ≠„Åõ„Çà„ÄÇ", en: "BLOCK THE NOISE" }, { jp: "Áîü„ÅçÊÆã„Çå„ÄÇ", en: "STAY ALIVE" }
            ]},
            BOREDOM: { id: 'BOREDOM', label: 'ANTI-BOREDOM / „Éù„Ç∏„Éù„Ç∏ÁóÖÈò≤Ê≠¢', timerLabel: { jp: 'Â•ΩÊ©ü„ÅåÊù•„Çã„Åæ„Åß', en: 'UNTIL OPPORTUNITY' }, words: [
                { jp: "ÂæÖ„Å§„ÅÆ„ÇÇÁõ∏Â†¥„ÄÇ", en: "WAITING IS TRADE" }, { jp: "ÂÄ§Âãï„Åç„ÅØ„Éé„Ç§„Ç∫„ÄÇ", en: "PRICE IS NOISE" },
                { jp: "ÁèæÂÆü„Å´Â∏∞„Çå„ÄÇ", en: "TOUCH GRASS" }, { jp: "ÈùôË¶≥„Åõ„Çà„ÄÇ", en: "STAY NEUTRAL" },
                { jp: "„Éù„Ç∏„Éù„Ç∏ÁóÖ„ÅØ‰∏çÊ≤ª„ÅÆÁóÖ„ÄÇ", en: "OVERTRADING KILLS" }, { jp: "Êöá„Å™„ÇâÊú¨„ÇíË™≠„ÇÅ„ÄÇ", en: "READ A BOOK" },
                { jp: "„Ç≥„Ç§„É≥„Éà„Çπ„Å®Âêå„Åò„Å†„ÄÇ", en: "JUST GAMBLING" }, { jp: "„ÉÅ„É£„Éº„Éà„ÇíË¶ãÈÅé„Åé„Çã„Å™„ÄÇ", en: "IGNORE TICKS" },
                { jp: "Ê©üÊ¢∞„Å´„Å™„Çå„ÄÇ", en: "BE A MACHINE" }, { jp: "‰∏ÄÂñú‰∏ÄÊÜÇ„ÅØË™≤Á®éÂØæË±°„ÄÇ", en: "EMOTION IS TAXED" },
                { jp: "‰Ωï„ÇÇ„Åó„Å™„ÅÑÂãáÊ∞ó„ÄÇ", en: "COURAGE TO DO NOTHING" }, { jp: "ÈÄÄÂ±à„ÅØÂà©Áõä„ÅÆÊ∫êÊ≥â„ÄÇ", en: "BOREDOM IS PROFIT" },
                { jp: "Ë≥áÈáë„ÇíÂÆà„Çå„ÄÇ", en: "PROTECT CAPITAL" }, { jp: "„ÉÅ„É£„É≥„Çπ„ÇíÂæÖ„Å¶„ÄÇ", en: "WAIT FOR SETUP" },
                { jp: "ÁÑ°ÁêÜ„Å´Âãï„Åè„Å™„ÄÇ", en: "DONT FORCE IT" }, { jp: "Ë¶èÂæã„ÇíÂÆà„Çå„ÄÇ", en: "DISCIPLINE" },
                { jp: "„Åù„Çå„ÅØÊäïË≥á„Åã„ÄÅ„ÇÆ„É£„É≥„Éñ„É´„Åã„ÄÇ", en: "INVEST OR GAMBLE?" }, { jp: "„Éó„É≠„ÅØÂæÖ„Å¶„Çã„ÄÇ", en: "PROS WAIT" },
                { jp: "‰ªäÊó•„ÅØPC„ÇíÈñâ„Åò„Çç„ÄÇ", en: "DAY OFF" }, { jp: "ÁûëÊÉ≥„Åõ„Çà„ÄÇ", en: "MEDITATE" }
            ]}
        };

        const COMPLETION_MESSAGES = [
            { jp: "Êúà„Å∏„ÄÅË°å„Å£„Å¶„Çâ„Å£„Åó„ÇÉ„ÅÑ„ÄÇ", en: "SAFE TRAVELS TO THE MOON" },
            { jp: "ÂçÉÈáå„ÅÆÈÅì„ÇÇ‰∏ÄÊ≠©„Åã„Çâ„ÄÇ", en: "ONE SMALL STEP" },
            { jp: "Ê∫ñÂÇô„ÅØÊï¥„Å£„Åü„ÄÇ", en: "SYSTEMS GO" },
            { jp: "Âπ∏ÈÅã„ÇíÁ•à„Çã„ÄÇ", en: "GOOD LUCK" },
            { jp: "ÂÜ∑Èùô„Åï„Çí‰øù„Å¶„ÄÇ", en: "STAY FROSTY" },
            { jp: "Ë¶èÂæã„Åì„Åù„ÅåËá™Áî±„Å†„ÄÇ", en: "DISCIPLINE IS FREEDOM" }
        ];

        const WORD_DURATION = 6000;
        const TIMER_DURATION = 180;

        // --- üî† DECODE TEXT ---
        const DecipherText = ({ text, trigger }) => {
            const [display, setDisplay] = useState("");
            useEffect(() => {
                let iteration = 0;
                let active = true;
                const interval = setInterval(() => {
                    if (!active) return;
                    setDisplay(text.split("").map((letter, index) => {
                        if (index < iteration) return text[index];
                        return "||//--.."[Math.floor(Math.random() * 8)];
                    }).join(""));
                    if (Math.random() > 0.9) playSound('tick');
                    if (iteration >= text.length) clearInterval(interval);
                    iteration += 1 / 2;
                }, 30);
                return () => { active = false; clearInterval(interval); };
            }, [text, trigger]);
            return <span>{display}</span>;
        };

        // --- üì± MAIN APP ---
        function App() {
            const [currentMode, setCurrentMode] = useState('LEGENDS');
            const [lang, setLang] = useState('JP');
            const [wordIndex, setWordIndex] = useState(0); 
            const [trigger, setTrigger] = useState(0);
            const [started, setStarted] = useState(false);
            const [timeLeft, setTimeLeft] = useState(TIMER_DURATION * 1000);
            const [finished, setFinished] = useState(false);
            const [isGlitching, setIsGlitching] = useState(false);

            useEffect(() => {
                document.body.classList.add('loaded');
            }, []);

            const getNextRandomIndex = useCallback((currentIndex, length) => {
                if (length <= 1) return 0;
                let next;
                do { next = Math.floor(Math.random() * length); } while (next === currentIndex);
                return next;
            }, []);

            const nextWord = useCallback(() => {
                const words = MODES[currentMode].words;
                setWordIndex(prev => getNextRandomIndex(prev, words.length));
                setTrigger(prev => prev + 1);
                playSound('switch');
            }, [currentMode, getNextRandomIndex]);

            useEffect(() => {
                if (!started || finished) return;
                const timer = setInterval(() => {
                    nextWord();
                }, 6000);
                return () => clearInterval(timer);
            }, [started, finished, nextWord]);

            useEffect(() => {
                if (!started || finished) return;
                const interval = setInterval(() => {
                    setTimeLeft(prev => {
                        if (prev <= 17) {
                            setFinished(true);
                            playSound('complete');
                            return 0;
                        }
                        return prev - 17;
                    });
                }, 17);
                return () => clearInterval(interval);
            }, [started, finished]);

            const switchMode = (modeKey) => {
                if (currentMode === modeKey) return;
                setIsGlitching(true);
                playSound('glitch');
                setTimeout(() => {
                    setCurrentMode(modeKey);
                    setWordIndex(Math.floor(Math.random() * MODES[modeKey].words.length));
                    setTrigger(prev => prev + 1);
                    setTimeout(() => setIsGlitching(false), 200);
                }, 100);
            };

            const toggleLang = (e) => {
                e.stopPropagation();
                setLang(prev => prev === 'JP' ? 'EN' : 'JP');
                playSound('switch');
            };

            const manualSkip = () => {
                if (!started || finished) return;
                nextWord();
                playSound('tick');
            };

            const formatTime = (ms) => {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const millis = Math.floor((ms % 1000) / 10);
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(millis).padStart(2, '0')}`;
            };

            const activeWords = MODES[currentMode].words;
            const safeIndex = wordIndex % activeWords.length;
            const activeWord = activeWords[safeIndex];
            const completionMsg = COMPLETION_MESSAGES[Math.floor(Math.random() * COMPLETION_MESSAGES.length)];

            const mainText = lang === 'JP' ? activeWord.jp : activeWord.en;
            const subText = lang === 'JP' ? activeWord.en : activeWord.jp;
            const mainFontClass = lang === 'JP' ? 'font-mincho tracking-normal' : 'font-sans tracking-tight font-black';
            const subFontClass = lang === 'JP' ? 'font-sans font-bold tracking-[0.2em]' : 'font-mincho tracking-widest font-bold';
            const timerLabel = lang === 'JP' ? MODES[currentMode].timerLabel.jp : MODES[currentMode].timerLabel.en;

            return (
                <div className={`w-full h-full flex flex-col justify-between relative transition-colors duration-100 ${isGlitching ? 'invert-mode' : ''}`}>
                    
                    {/* LANG BUTTON (Fixed Top Right) */}
                    {started && (
                        <div className="absolute top-6 right-6 z-50">
                            <button onClick={toggleLang} className="px-4 py-2 bg-white border-2 border-gray-100 text-xs font-sans font-bold tracking-widest hover:bg-black hover:text-white transition-colors rounded-sm shadow-sm cursor-pointer">
                                {lang === 'JP' ? 'EN' : 'JP'}
                            </button>
                        </div>
                    )}

                    {/* START SCREEN (Centered) */}
                    {!started && (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center p-4 bg-[#FAFAFA]">
                            <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 1 }} className="text-center px-4">
                                <h1 className="font-mincho font-extrabold text-5xl md:text-8xl mb-12 text-black leading-tight tracking-tight">
                                    FOMO„Å´Âäπ„Åè<br/>100„ÅÆË®ÄËëâ
                                </h1>
                                <button onClick={() => { setStarted(true); playSound('switch'); }} className="group relative px-12 py-4 bg-transparent border-2 border-black overflow-hidden cursor-pointer inline-block">
                                    <span className="relative z-10 font-mincho font-bold text-lg tracking-[0.2em] group-hover:text-white transition-colors duration-300">Ë¶ã„Å¶„Åø„Çã</span>
                                    <div className="absolute inset-0 bg-black transform -translate-x-full group-hover:translate-x-0 transition-transform duration-300 ease-out"></div>
                                </button>
                                <p className="font-sans font-bold text-[10px] tracking-[0.4em] text-gray-400 mt-12">ANTI-FOMO PROTOCOL</p>
                            </motion.div>
                        </div>
                    )}

                    {/* --- MAIN STRUCTURE (Flex Column with Spacing) --- */}
                    {started && (
                        <>
                            {/* TOP: Timer & Info (Fixed Height Block) */}
                            <div className="flex-none pt-12 pb-4 w-full flex flex-col items-center justify-start z-30">
                                <div className="font-mincho text-[10px] tracking-[0.4em] mb-2 text-gray-400 opacity-80">
                                    {timerLabel}
                                </div>
                                <div className="font-mono text-xl md:text-2xl tracking-[0.3em] text-black font-light tabular-nums">
                                    {formatTime(timeLeft)}
                                </div>
                            </div>

                            {/* MIDDLE: Content (Takes Remaining Space) */}
                            <div className="flex-grow flex flex-col justify-center items-center relative z-20 w-full px-4 cursor-pointer hover:opacity-80 transition-opacity" onClick={manualSkip}>
                                <AnimatePresence mode="wait">
                                    {!finished ? (
                                        <motion.div key={`${currentMode}-${trigger}-${lang}`} initial={{ opacity: 0, filter: "blur(5px)" }} animate={{ opacity: 1, filter: "blur(0px)" }} exit={{ opacity: 0, filter: "blur(5px)" }} transition={{ duration: 0.2 }} className={`flex flex-col items-center ${isGlitching ? 'glitch-active' : ''}`}>
                                            
                                            {/* No. */}
                                            <div className="font-sans font-black text-xs tracking-[0.4em] mb-6 text-chart-green opacity-90">
                                                NO. {String(safeIndex + 1).padStart(2, '0')}
                                            </div>
                                            
                                            {/* Main Words */}
                                            <h1 className={`${mainFontClass} text-5xl md:text-7xl lg:text-8xl leading-tight text-black text-center mb-6 break-words`}>
                                                <DecipherText text={mainText} trigger={trigger} />
                                            </h1>
                                            
                                            {/* Sub Words */}
                                            <p className={`${subFontClass} text-xs md:text-sm text-gray-400 uppercase`}>
                                                {subText}
                                            </p>

                                        </motion.div>
                                    ) : (
                                        <motion.div key="finished" initial={{ opacity: 0 }} animate={{ opacity: 1 }} className="text-center">
                                            <h1 className="font-mincho font-extrabold text-5xl md:text-7xl text-black mb-6">
                                                <DecipherText text={lang === 'JP' ? completionMsg.jp : completionMsg.en} />
                                            </h1>
                                            <p className="font-sans font-bold text-sm text-gray-400 tracking-[0.2em] uppercase">
                                                {lang === 'JP' ? completionMsg.en : completionMsg.jp}
                                            </p>
                                        </motion.div>
                                    )}
                                </AnimatePresence>
                            </div>

                            {/* BOTTOM: Buttons (Fixed Height Block) */}
                            <div className="flex-none pb-12 pt-4 w-full flex justify-center items-end z-30">
                                <div className="pointer-events-auto">
                                    {!finished ? (
                                        <div className="flex flex-wrap justify-center gap-3 px-4">
                                            {Object.keys(MODES).map((key) => (
                                                <button key={key} onClick={(e) => { e.stopPropagation(); switchMode(key); }} className={`font-sans font-bold text-[10px] md:text-xs tracking-[0.1em] px-6 py-4 transition-all border rounded-sm ${currentMode === key ? 'bg-black text-white border-black' : 'bg-white/90 text-gray-400 border-gray-200 hover:border-black hover:text-black shadow-sm'}`}>
                                                    {MODES[key].label}
                                                </button>
                                            ))}
                                        </div>
                                    ) : (
                                        <button onClick={() => window.location.reload()} className="font-sans font-bold text-xs tracking-[0.2em] px-10 py-4 border border-gray-200 bg-white text-gray-400 hover:text-black hover:border-black transition-all rounded-sm">
                                            REBOOT SYSTEM
                                        </button>
                                    )}
                                </div>
                            </div>
                        </>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
